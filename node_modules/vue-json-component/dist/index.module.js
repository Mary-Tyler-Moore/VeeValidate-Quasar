import { __assign } from 'tslib';
import Vue from 'vue';

function _typeof(obj) {
  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    _typeof = function (obj) {
      return typeof obj;
    };
  } else {
    _typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return _typeof(obj);
}

var script = Vue.extend({
  name: "json-view-item",
  data: function data() {
    return {
      open: this.data.depth < this.maxDepth
    };
  },
  props: {
    data: {
      required: true,
      type: Object
    },
    maxDepth: {
      type: Number,
      required: false,
      default: 1
    },
    styles: {
      type: Object,
      required: true
    },
    canSelect: {
      type: Boolean,
      required: false,
      default: false
    }
  },
  methods: {
    toggleOpen: function toggleOpen() {
      this.open = !this.open;
    },
    clickEvent: function clickEvent(data) {
      this.$emit("selected", {
        key: data.key,
        value: data.value,
        path: data.path
      });
    },
    bubbleSelected: function bubbleSelected(data) {
      this.$emit("selected", data);
    },
    getKey: function getKey(value) {
      if (!isNaN(value.key)) {
        return value.key + ":";
      } else {
        return '"' + value.key + '":';
      }
    },
    getValueStyle: function getValueStyle(value) {
      var type = _typeof(value);

      switch (type) {
        case "string":
          return {
            color: this.styles.string
          };

        case "number":
          return {
            color: this.styles.number
          };

        case "boolean":
          return {
            color: this.styles.boolean
          };

        case "object":
          return {
            color: this.styles.null
          };

        default:
          return {
            color: this.styles.valueKeyColor
          };
      }
    }
  },
  computed: {
    classes: function classes() {
      return {
        "chevron-arrow": true,
        opened: this.open
      };
    },
    valueClasses: function valueClasses() {
      return {
        "value-key": true,
        "can-select": this.canSelect
      };
    },
    arrowStyles: function arrowStyles() {
      return {
        width: this.styles.arrowSize,
        height: this.styles.arrowSize
      };
    },
    lengthString: function lengthString() {
      if (this.data.type === "array") {
        return this.data.length === 1 ? this.data.length + " element" : this.data.length + " elements";
      }

      return this.data.length === 1 ? this.data.length + " property" : this.data.length + " properties";
    },
    keyColor: function keyColor() {
      return {
        color: this.styles.key
      };
    },
    valueKeyColor: function valueKeyColor() {
      return {
        color: this.styles.valueKey
      };
    }
  }
});

/* script */
var __vue_script__ = script;
/* template */

var __vue_render__ = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    staticClass: "json-view-item"
  }, [_vm.data.type === 'object' || _vm.data.type === 'array' ? _c('div', [_c('div', {
    staticClass: "data-key",
    style: _vm.keyColor,
    on: {
      "click": function click($event) {
        $event.stopPropagation();
        return _vm.toggleOpen($event);
      }
    }
  }, [_c('div', {
    class: _vm.classes,
    style: _vm.arrowStyles
  }), _vm._v("\n      " + _vm._s(_vm.data.key) + ":\n      "), _c('span', {
    staticClass: "properties"
  }, [_vm._v("Â " + _vm._s(_vm.lengthString))])]), _vm._v(" "), _vm._l(_vm.data.children, function (child) {
    return _c('json-view-item', {
      directives: [{
        name: "show",
        rawName: "v-show",
        value: _vm.open,
        expression: "open"
      }],
      key: _vm.getKey(child),
      attrs: {
        "data": child,
        "maxDepth": _vm.maxDepth,
        "styles": _vm.styles,
        "canSelect": _vm.canSelect
      },
      on: {
        "selected": _vm.bubbleSelected
      }
    });
  })], 2) : _vm._e(), _vm._v(" "), _vm.data.type === 'value' ? _c('div', {
    class: _vm.valueClasses,
    on: {
      "click": function click($event) {
        return _vm.clickEvent(_vm.data);
      }
    }
  }, [_c('span', {
    style: _vm.valueKeyColor
  }, [_vm._v(" " + _vm._s(_vm.data.key) + ": ")]), _vm._v(" "), _c('span', {
    style: _vm.getValueStyle(_vm.data.value)
  }, [_vm._v("\n      " + _vm._s(JSON.stringify(_vm.data.value)) + "\n    ")])]) : _vm._e()]);
};

var __vue_staticRenderFns__ = [];
/* style */

var __vue_inject_styles__ = function __vue_inject_styles__(inject) {
  if (!inject) return;
  inject("data-v-5ef773f2_0", {
    source: ".json-view-item[data-v-5ef773f2]{margin-left:20px}.value-key[data-v-5ef773f2]{font-weight:600;margin-left:10px;border-radius:2px;white-space:nowrap;padding:5px 5px 5px 10px}.value-key.can-select[data-v-5ef773f2]{cursor:pointer}.value-key.can-select[data-v-5ef773f2]:hover{background-color:rgba(0,0,0,.08)}.data-key[data-v-5ef773f2]{display:flex;align-items:center;border-radius:2px;font-weight:600;cursor:pointer;white-space:nowrap;padding:5px}.data-key[data-v-5ef773f2]:hover{background-color:rgba(0,0,0,.08)}.data-key .properties[data-v-5ef773f2]{font-weight:300;opacity:.6;user-select:none}.chevron-arrow[data-v-5ef773f2]{flex-shrink:0;border-right:4px solid #444;border-bottom:4px solid #444;width:6px;height:6px;margin-right:20px;margin-left:5px;transform:rotate(-45deg)}.chevron-arrow.opened[data-v-5ef773f2]{margin-top:-3px;transform:rotate(45deg)}",
    map: undefined,
    media: undefined
  });
};
/* scoped */


var __vue_scope_id__ = "data-v-5ef773f2";
/* module identifier */

var __vue_module_identifier__ = undefined;
/* functional template */

var __vue_is_functional_template__ = false;
/* component normalizer */

function __vue_normalize__(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

  component.__file = "JSONViewItem.vue";

  if (!component.render) {
    component.render = template.render;
    component.staticRenderFns = template.staticRenderFns;
    component._compiled = true;
    if (functional) component.functional = true;
  }

  component._scopeId = scope;

  {
    var hook;

    if (style) {
      hook = function hook(context) {
        style.call(this, createInjector(context));
      };
    }

    if (hook !== undefined) {
      if (component.functional) {
        // register for functional component in vue file
        var originalRender = component.render;

        component.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        // inject component registration as beforeCreate hook
        var existing = component.beforeCreate;
        component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }
  }

  return component;
}
/* style inject */


function __vue_create_injector__() {
  var head = document.head || document.getElementsByTagName('head')[0];
  var styles = __vue_create_injector__.styles || (__vue_create_injector__.styles = {});
  var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
  return function addStyle(id, css) {
    if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

    var group = isOldIE ? css.media || 'default' : id;
    var style = styles[group] || (styles[group] = {
      ids: [],
      parts: [],
      element: undefined
    });

    if (!style.ids.includes(id)) {
      var code = css.source;
      var index = style.ids.length;
      style.ids.push(id);

      if (css.map) {
        // https://developer.chrome.com/devtools/docs/javascript-debugging
        // this makes source maps inside style tags work properly in Chrome
        code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

        code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
      }

      if (isOldIE) {
        style.element = style.element || document.querySelector('style[data-group=' + group + ']');
      }

      if (!style.element) {
        var el = style.element = document.createElement('style');
        el.type = 'text/css';
        if (css.media) el.setAttribute('media', css.media);

        if (isOldIE) {
          el.setAttribute('data-group', group);
          el.setAttribute('data-next-index', '0');
        }

        head.appendChild(el);
      }

      if (isOldIE) {
        index = parseInt(style.element.getAttribute('data-next-index'));
        style.element.setAttribute('data-next-index', index + 1);
      }

      if (style.element.styleSheet) {
        style.parts.push(code);
        style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
      } else {
        var textNode = document.createTextNode(code);
        var nodes = style.element.childNodes;
        if (nodes[index]) style.element.removeChild(nodes[index]);
        if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
      }
    }
  };
}
/* style inject SSR */


var JSONViewItem = __vue_normalize__({
  render: __vue_render__,
  staticRenderFns: __vue_staticRenderFns__
}, __vue_inject_styles__, __vue_script__, __vue_scope_id__, __vue_is_functional_template__, __vue_module_identifier__, __vue_create_injector__, undefined);

var script$1 = Vue.extend({
  name: "json-view",
  props: {
    data: {
      required: true,
      type: Object
    },
    rootKey: {
      type: String,
      required: false,
      default: "root"
    },
    maxDepth: {
      type: Number,
      required: false,
      default: 1
    },
    styles: {
      type: Object,
      required: false
    }
  },
  components: {
    "json-view-item": JSONViewItem
  },
  methods: {
    build: function build(key, val, depth, path, includeKey) {
      if (this.isObject(val)) {
        // Build Object
        var children = [];

        for (var _i = 0, _a = Object.entries(val); _i < _a.length; _i++) {
          var _b = _a[_i],
              childKey = _b[0],
              childValue = _b[1];
          children.push(this.build(childKey, childValue, depth + 1, includeKey ? "" + path + key + "." : "" + path, true));
        }

        return {
          key: key,
          type: "object",
          depth: depth,
          path: path,
          length: children.length,
          children: children
        };
      } else if (this.isArray(val)) {
        // Build Array
        var children = [];

        for (var i = 0; i < val.length; i++) {
          children.push(this.build(i.toString(), val[i], depth + 1, includeKey ? "" + path + key + "[" + i + "]." : "" + path, false));
        }

        return {
          key: key,
          type: "array",
          depth: depth,
          path: path,
          length: children.length,
          children: children
        };
      } else {
        // Build Value
        return {
          key: key,
          type: "value",
          path: includeKey ? path + key : path.slice(0, -1),
          depth: depth,
          value: val
        };
      }
    },
    isObject: function isObject(val) {
      return _typeof(val) === "object" && val !== null && !this.isArray(val);
    },
    isArray: function isArray(val) {
      return Array.isArray(val);
    },
    itemSelected: function itemSelected(data) {
      this.$emit("selected", data);
    }
  },
  computed: {
    parsed: function parsed() {
      return this.build(this.rootKey, __assign({}, this.data), 0, "", true);
    },
    customStyles: function customStyles() {
      var target = {
        key: "#002b36",
        valueKey: "#073642",
        string: "#268bd2",
        number: "#2aa198",
        boolean: "#cb4b16",
        null: "#6c71c4",
        arrowSize: "6px"
      };
      return Object.assign(target, this.styles);
    },
    hasSelectedListener: function hasSelectedListener() {
      return Boolean(this.$listeners && this.$listeners.selected);
    }
  }
});

/* script */
var __vue_script__$1 = script$1;
/* template */

var __vue_render__$1 = function __vue_render__() {
  var _vm = this;

  var _h = _vm.$createElement;

  var _c = _vm._self._c || _h;

  return _c('div', {
    attrs: {
      "id": "json-view"
    }
  }, [_c('json-view-item', {
    attrs: {
      "id": "root-item",
      "data": _vm.parsed,
      "maxDepth": _vm.maxDepth,
      "styles": _vm.customStyles,
      "canSelect": _vm.hasSelectedListener
    },
    on: {
      "selected": _vm.itemSelected
    }
  })], 1);
};

var __vue_staticRenderFns__$1 = [];
/* style */

var __vue_inject_styles__$1 = function __vue_inject_styles__(inject) {
  if (!inject) return;
  inject("data-v-1ba595d2_0", {
    source: "#json-view{width:100%;height:auto}#root-item{margin-left:0}",
    map: undefined,
    media: undefined
  });
};
/* scoped */


var __vue_scope_id__$1 = undefined;
/* module identifier */

var __vue_module_identifier__$1 = undefined;
/* functional template */

var __vue_is_functional_template__$1 = false;
/* component normalizer */

function __vue_normalize__$1(template, style, script, scope, functional, moduleIdentifier, createInjector, createInjectorSSR) {
  var component = (typeof script === 'function' ? script.options : script) || {}; // For security concerns, we use only base name in production mode.

  component.__file = "JSONView.vue";

  if (!component.render) {
    component.render = template.render;
    component.staticRenderFns = template.staticRenderFns;
    component._compiled = true;
    if (functional) component.functional = true;
  }

  component._scopeId = scope;

  {
    var hook;

    if (style) {
      hook = function hook(context) {
        style.call(this, createInjector(context));
      };
    }

    if (hook !== undefined) {
      if (component.functional) {
        // register for functional component in vue file
        var originalRender = component.render;

        component.render = function renderWithStyleInjection(h, context) {
          hook.call(context);
          return originalRender(h, context);
        };
      } else {
        // inject component registration as beforeCreate hook
        var existing = component.beforeCreate;
        component.beforeCreate = existing ? [].concat(existing, hook) : [hook];
      }
    }
  }

  return component;
}
/* style inject */


function __vue_create_injector__$1() {
  var head = document.head || document.getElementsByTagName('head')[0];
  var styles = __vue_create_injector__$1.styles || (__vue_create_injector__$1.styles = {});
  var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\\b/.test(navigator.userAgent.toLowerCase());
  return function addStyle(id, css) {
    if (document.querySelector('style[data-vue-ssr-id~="' + id + '"]')) return; // SSR styles are present.

    var group = isOldIE ? css.media || 'default' : id;
    var style = styles[group] || (styles[group] = {
      ids: [],
      parts: [],
      element: undefined
    });

    if (!style.ids.includes(id)) {
      var code = css.source;
      var index = style.ids.length;
      style.ids.push(id);

      if (css.map) {
        // https://developer.chrome.com/devtools/docs/javascript-debugging
        // this makes source maps inside style tags work properly in Chrome
        code += '\n/*# sourceURL=' + css.map.sources[0] + ' */'; // http://stackoverflow.com/a/26603875

        code += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(css.map)))) + ' */';
      }

      if (isOldIE) {
        style.element = style.element || document.querySelector('style[data-group=' + group + ']');
      }

      if (!style.element) {
        var el = style.element = document.createElement('style');
        el.type = 'text/css';
        if (css.media) el.setAttribute('media', css.media);

        if (isOldIE) {
          el.setAttribute('data-group', group);
          el.setAttribute('data-next-index', '0');
        }

        head.appendChild(el);
      }

      if (isOldIE) {
        index = parseInt(style.element.getAttribute('data-next-index'));
        style.element.setAttribute('data-next-index', index + 1);
      }

      if (style.element.styleSheet) {
        style.parts.push(code);
        style.element.styleSheet.cssText = style.parts.filter(Boolean).join('\n');
      } else {
        var textNode = document.createTextNode(code);
        var nodes = style.element.childNodes;
        if (nodes[index]) style.element.removeChild(nodes[index]);
        if (nodes.length) style.element.insertBefore(textNode, nodes[index]);else style.element.appendChild(textNode);
      }
    }
  };
}
/* style inject SSR */


var JSONView = __vue_normalize__$1({
  render: __vue_render__$1,
  staticRenderFns: __vue_staticRenderFns__$1
}, __vue_inject_styles__$1, __vue_script__$1, __vue_scope_id__$1, __vue_is_functional_template__$1, __vue_module_identifier__$1, __vue_create_injector__$1, undefined);

var index = {
  install: function install(Vue, options) {
    Vue.component("json-view", JSONView);
  }
};

export default index;
export { JSONView };
//# sourceMappingURL=index.module.js.map
